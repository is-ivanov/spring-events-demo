# spring-event-demo

# Тестирование как ведут себя Spring Events и разные Listeners
## Исходные данные
Spring Boot v 3.5.6.
Класс `Visit`. При создании визита должны "создаваться" уведомления `Notification`. 2 события `VisitCreatedEvent` и `VisitCreatedFailNotificationEvent` чтобы проще симулировать отказы БД.
При создании визита создаются 2 события: одно доменное в `Visit`, второе в сервисе `VisitService`.
## Кейс 1. @EventListener
Обработчики событий выполняются в этом же потоке как и "основной" флоу и в одной транзакции. Т.е. после выполнения метода `repository.save()` публикуется доменный эвент, затем сразу же он ловится и обрабатывается, и только после этого поток управления возвращается в сервис и выполняется `applicationEventPublisher.publishEvent(new VisitCreatedEvent(entity.getType(), "Service event"));`. Единственная транзакция коммитится в конце метода.
Соответственно, при ошибках, либо при сохранении визита, либо при сохранении эвента, всё транзакция откатывается.
## Кейс 2. @Async + @EventListener
Лисенеры выполняются асинхронно в отдельных потоках и в отдельных транзакциях. Поэтому если происходит ошибка в ходе выполнения кода "нотификации", то в БД остаётся созданный визит, т.к. его транзакция закоммитилась.
## Кейс 3. @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
Лисенеры выполняются в основном потоке, но после коммита транзакции. Т.о. сначала:
1. открывается транзакция
2.  происходит `INSERT` визита в БД
3. затем публикуются эвенты (сначала доменный, затем сервисный),
4. затем транзакция коммитится,
5. и затем только выполняется код методов Лисенеров.

При таком подходе, операции по созданию нотификаций вроде происходят, и в логах есть записи `jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(217513079<open>)] for JPA transaction`, `jpa.JpaTransactionManager   : Participating in existing transaction`, но т.к. транзакция уже закоммитилась, то нотификации в БД не сохраняются.
## Кейс 4. @TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT)
Всё выполняется в одном потоке. Поток выполнения не перескакивает из основного метода в методы Лисенеров. Т.е. сначала выполняется INSERT, затем публикуются события и выполняется код "основного метода", затем только поток переходит к выполнению кода методов Лисенеров.
## Кейс 5. @Async + @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
Выполняются в разных потоках. События обрабатываются после коммита основной транзакции в своих транзакциях.
## Кейс 6. @Async + @TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT)
Выполняются в разных потоках. События обрабатываются в своих потоках/транзакциях.
## Кейс 7. @ApplicationModuleListener - Modulith
При создании визита после `insert into visit` в этом же потоке и транзакции происходит вставка `insert into event_publication`, где `completion_date = null`. Транзакция коммтися.
Далее в отдельных потоках, в своих новых транзакциях обрабатываются нотификации, и эти транзакции коммитятся.
Далее в этих же отдельных потоках открываются новые транзакции для обработки этих `event_publication`, где производится update с установкой `completion_date`.
